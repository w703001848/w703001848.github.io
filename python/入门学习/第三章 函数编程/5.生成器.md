# 生成器

生成器本质是迭代器

唯一区别：

​	`生成器`由`yield`构建的数据结构。

​	`迭代器`由官方提供或者`iter`转化的。

## yield

```python
def func():
    print(1)
    yield 3
    yield 3
    print(1)
    yield 3
ref = func()
print(next(ref))
print(next(ref))
print(next(ref))
```

>   使用`yield`而变成`generator`的函数，每个`next()`对应一个`yield`，在每次调用`next()`的时候执行，遇到`yield`语句暂停并返回数据到函数外，再次被`next()`调用时从上次返回的`yield`语句处继续执行。

>   注意：`return`与`yield`区别
>   -   `return`每个函数执行到第一个`return`就结束函数，并且执行返回值
>   -   `yield`在函数中存在就是生成器函数而不是函数，遇到`yield`不会结束，而是等待下次调用

## yield from

将返回值转化成迭代器返回

```python
def func():
	l1 = [1,2,3,4]
	l2 = [5,6,7,8]
	yield from l1
	yield from l2
ref = func()
for i in range(8):
	print(next(ref))
```

>   用`yield`则需要写8次，而`yield from`方式等价

## 列表生成器

```python

```

## 函数生成器



```python
def fib(max):
  a,b = 0,1
  n = 0  # 斐波那契数
  while n < max:
    n = a + b
    a = b # 把b的旧值给到a
    b = n # 新的b = a + b(旧b的值)
    #print(n)
    yield n # 程序走到这，就会暂停下来，返回n到函数外面，直到被next方法调用时唤醒
f = fib(100) # 注意这句调用时，函数并不会执行，只有下一次调用next时，函数才会真正执行
print(next(f))
print(f.__next__()) # 同next(f)
```

